## âœ… Week 11 â€” Introduction to Algorithm Efficiency & Big O

**Theme:** Understanding time complexity and evaluating algorithm efficiency

---

### ğŸ¯ Learning Objectives

By the end of Week 11, students will be able to:

* âœ… Explain the concept of algorithm efficiency
* âœ… Identify **constant**, **linear**, and **quadratic** time complexity
* âœ… Analyze loops and nested loops for performance
* âœ… Compare multiple solutions based on efficiency
* âœ… Apply basic optimization strategies to code

---

### ğŸ“˜ Deep Concepts Explained

#### ğŸ”¹ What is Algorithm Efficiency?

**Definition:** How fast a program runs or how much memory it uses as the input grows.

**Real-world analogy:**

* Searching for a book in a small bookshelf (fast) vs. a huge library (slow)
* Algorithm efficiency measures **scalability**

---

#### ğŸ”¹ Big O Notation

* Describes **upper bound** of runtime growth as input size increases
* Common examples:

| Complexity  | Symbol   | Example                           |
| ----------- | -------- | --------------------------------- |
| Constant    | O(1)     | Accessing first element of a list |
| Linear      | O(n)     | Looping through list of n items   |
| Quadratic   | O(nÂ²)    | Nested loops over n items         |
| Logarithmic | O(log n) | Binary search                     |

---

#### ğŸ”¹ Examples

**O(1) â€” Constant Time**

```python
numbers = [1,2,3,4,5]
print(numbers[0])  # Always one operation
```

**O(n) â€” Linear Time**

```python
for i in range(5):
    print(i)  # Number of operations grows linearly with n
```

**O(nÂ²) â€” Quadratic Time**

```python
for i in range(5):
    for j in range(5):
        print(i, j)  # Nested loops â†’ n*n operations
```

---

#### ğŸ”¹ Analyzing Loops

* Single loop over `n` items â†’ O(n)
* Nested loop (loop inside loop over same `n`) â†’ O(nÂ²)
* Multiple consecutive loops â†’ O(n) + O(n) = O(n)
* Nested loops + separate loops â†’ O(nÂ² + n) = O(nÂ²)

**Key:** Only the **dominant term** matters for large `n`.

---

#### ğŸ”¹ Practical Tip

* Avoid unnecessary nested loops
* Use data structures (sets, dicts) to reduce repeated scanning
* Precompute values if needed

```python
# Example: Count duplicates efficiently using dictionary
numbers = [1,2,3,1,2,1]
freq = {}
for num in numbers:
    freq[num] = freq.get(num,0) + 1  # O(n)
```

---

### âœ… Python Code Examples

#### Example 1 â€” Linear vs Quadratic

```python
# Linear
numbers = [1,2,3,4,5]
for n in numbers:
    print(n)

# Quadratic
for i in numbers:
    for j in numbers:
        print(i,j)
```

#### Example 2 â€” Optimized Counting

```python
numbers = [1,2,3,1,2,1]
freq = {}
for num in numbers:
    freq[num] = freq.get(num,0) + 1
print(freq)
```

---

### ğŸ–¼ï¸ Diagrams (Placeholders)

* ![Big O Growth Chart](images/week11-bigO-growth.png)
* ![Loop Complexity Comparison](images/week11-loop-comparison.png)
* ![Optimization Example Flow](images/week11-optimization-flow.png)

---

### ğŸ« In-Class Exercises (3)

1. Identify the time complexity of single vs nested loops in a code snippet.
2. Count elements greater than 10 in a list and determine Big O.
3. Compare two algorithms that find duplicates in a list: brute-force vs dictionary.

---

### âœ… Solutions

**Exercise 1**

```python
# Single loop â†’ O(n)
for i in range(n):
    print(i)

# Nested loop â†’ O(n^2)
for i in range(n):
    for j in range(n):
        print(i,j)
```

**Exercise 2**

```python
numbers = [5,12,7,15,3]
count = 0
for num in numbers:  # O(n)
    if num > 10:
        count += 1
print(count)
```

**Exercise 3**

```python
# Brute force â†’ O(n^2)
numbers = [1,2,3,1,2]
for i in numbers:
    for j in numbers:
        if i == j and i != j:
            print("Duplicate found")  

# Dictionary â†’ O(n)
freq = {}
for num in numbers:
    freq[num] = freq.get(num,0)+1
print(freq)
```

---

### ğŸ  Take-Home Assignments (3)

1. Input a list of N numbers, determine whether there are duplicates (use efficient method).
2. Compare two different implementations of summing numbers 1â€¦N, analyze Big O.
3. Create a nested loop program and analyze its time complexity; suggest optimizations.

---

### ğŸ“š References

* *Grokking Algorithms* â€” Chapters 1â€“2
* *Introduction to Algorithms* â€” Section 2.1
* Python Docs: [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)

---

### âš ï¸ Common Mistakes & Best Practices

| Mistake                                 | Solution                                  |
| --------------------------------------- | ----------------------------------------- |
| Assuming single operation for all loops | Count iterations properly                 |
| Ignoring dominant term                  | Only the largest term matters for large n |
| Nested loops when not needed            | Use dictionaries/sets to reduce O(nÂ²)     |

---

### ğŸ”® Next Week Preview

**Week 12 â€” Mini Project: Search & Counting Application**

* Build a small application combining lists, dictionaries, loops
* Apply linear search and counting algorithms
* Handle user input and exceptions
* Optimize performance and test with sample data

---
