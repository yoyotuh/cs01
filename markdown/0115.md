## âœ… Week 15 â€” Advanced Topics: Recursion, Searching, and Sorting

**Theme:** Recursive problem solving, searching algorithms, and introduction to efficient sorting

---

### ðŸŽ¯ Learning Objectives

By the end of Week 15, students will be able to:

* âœ… Apply recursion to common algorithmic problems
* âœ… Implement linear and binary search
* âœ… Understand the difference between O(n) and O(log n) complexity
* âœ… Explore recursive sorting strategies (merge sort overview)
* âœ… Debug recursive and search-based algorithms

---

### ðŸ“˜ Deep Concepts Explained

#### ðŸ”¹ Recursion Recap

* Recursion = function calls itself
* Must have **base case** and **progress toward it**
* Useful for tree structures, divide-and-conquer problems, and factorial/Fibonacci sequences

**Example: Sum of List Recursively**

```python
def sum_list(lst):
    if not lst:  # base case: empty list
        return 0
    return lst[0] + sum_list(lst[1:])

print(sum_list([1,2,3,4,5]))  # Output: 15
```

---

#### ðŸ”¹ Linear Search

* O(n) complexity, simple sequential check

```python
def linear_search(lst, target):
    for i, val in enumerate(lst):
        if val == target:
            return i
    return -1

numbers = [3,5,7,9,11]
print(linear_search(numbers, 7))  # 2
```

**Real-world analogy:** Searching for a name in an unordered guest list by checking each entry.

---

#### ðŸ”¹ Binary Search

* Requires **sorted list**
* Divides search space by half each step â†’ O(log n)

```python
def binary_search(lst, target):
    left, right = 0, len(lst)-1
    while left <= right:
        mid = (left + right) // 2
        if lst[mid] == target:
            return mid
        elif lst[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

numbers = [1,3,5,7,9,11]
print(binary_search(numbers, 7))  # 3
```

**Visual intuition:**

* Search range halves each iteration: [1,3,5,7,9,11] â†’ mid = 5 â†’ target>mid â†’ search [7,9,11] â†’ mid = 9 â†’ target<mid â†’ found 7

---

#### ðŸ”¹ Merge Sort (Overview)

* Divide list â†’ sort halves â†’ merge sorted halves
* O(n log n) complexity â†’ much faster than bubble/selection sort for large datasets

```python
def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    mid = len(lst)//2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result

numbers = [38,27,43,3,9,82,10]
print(merge_sort(numbers))
```

---

### âœ… Python Code Examples

#### Example 1 â€” Recursive Fibonacci

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print([fibonacci(i) for i in range(10)])  # First 10 Fibonacci numbers
```

#### Example 2 â€” Linear vs Binary Search

```python
lst = [1,3,5,7,9,11]
print("Linear Search:", linear_search(lst, 9))
print("Binary Search:", binary_search(lst, 9))
```

#### Example 3 â€” Recursive Sum of Nested Lists

```python
def recursive_sum(lst):
    total = 0
    for item in lst:
        if isinstance(item, list):
            total += recursive_sum(item)
        else:
            total += item
    return total

nested = [1, [2,3], [4, [5,6]]]
print(recursive_sum(nested))  # Output: 21
```

---

### ðŸ–¼ï¸ Diagrams (Placeholders)

* ![Binary Search Flow](images/week15-binary-search-flow.png)
* ![Recursive List Sum Flow](images/week15-recursive-sum-flow.png)
* ![Merge Sort Flow](images/week15-merge-sort-flow.png)

---

### ðŸ« In-Class Exercises (3)

1. Implement linear search and binary search, compare number of steps for target.
2. Write a recursive function to reverse a string.
3. Implement merge sort on a small list of integers and print intermediate steps.

---

### âœ… Solutions

**Exercise 1**

```python
numbers = [1,3,5,7,9,11]

def linear_search(lst, target):
    for i, val in enumerate(lst):
        if val == target:
            return i
    return -1

def binary_search(lst, target):
    left, right = 0, len(lst)-1
    while left <= right:
        mid = (left+right)//2
        if lst[mid] == target:
            return mid
        elif lst[mid] < target:
            left = mid+1
        else:
            right = mid-1
    return -1

print(linear_search(numbers, 7))  # 3
print(binary_search(numbers, 7))  # 3
```

**Exercise 2**

```python
def reverse_string(s):
    if s == "":
        return ""
    return s[-1] + reverse_string(s[:-1])

print(reverse_string("hello"))  # "olleh"
```

**Exercise 3**

```python
numbers = [38,27,43,3,9,82,10]

def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    mid = len(lst)//2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result

print(merge_sort(numbers))
```

---

### ðŸ  Take-Home Assignments (3)

1. Implement a recursive function to find the maximum in a list.
2. Implement binary search on a sorted list of strings.
3. Compare merge sort and bubble sort on a list of 20 integers and count operations.

---

### ðŸ“š References

* *Grokking Algorithms* â€” Chapters 2â€“5
* *Problem Solving with Algorithms and Data Structures* â€” Recursion & Sorting
* Python Docs: [https://docs.python.org/3/tutorial/controlflow.html#defining-functions](https://docs.python.org/3/tutorial/controlflow.html#defining-functions)

---

### âš ï¸ Common Mistakes & Best Practices

| Mistake                                    | Solution                              |
| ------------------------------------------ | ------------------------------------- |
| Missing base case in recursion             | Always define clear termination       |
| Binary search on unsorted list             | Sort list first                       |
| Modifying list while iterating recursively | Use slices or helper functions        |
| Deep recursion â†’ stack overflow            | Use iterative approach for large data |

---

### ðŸ”® Next Week Preview

**Week 16 â€” Final Capstone Project**

* Integrate all learned concepts: loops, functions, recursion, search, sorting
* Design and implement a complete application
* Apply debugging and optimization strategies
* Prepare project report and test cases

---
